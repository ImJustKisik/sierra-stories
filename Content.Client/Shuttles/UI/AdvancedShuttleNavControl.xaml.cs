using System;
using System.Numerics;
using Content.Shared.Shuttles.BUIStates;
using Content.Shared.Shuttles.Components;
using Content.Shared.Shuttles.Systems;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Collections;
using Robust.Shared.Graphics;
using Robust.Shared.Input;
using Robust.Shared.Map;
using Robust.Shared.Map.Components;
using Robust.Shared.Maths;
using Robust.Shared.Audio;
using Robust.Shared.Audio.Systems;
using Robust.Shared.Physics;
using Robust.Shared.Physics.Components;
using Robust.Shared.Utility;
using Robust.Shared.GameObjects;
using Robust.Shared.Localization;
using Robust.Shared.IoC;
using Robust.Shared.Random;
using Robust.Shared.Player;

namespace Content.Client.Shuttles.UI;

[GenerateTypedNameReferences]
public sealed partial class AdvancedShuttleNavControl : BaseShuttleControl
{
    [Dependency] private readonly IMapManager _mapManager = default!;
    [Dependency] private readonly IRobustRandom _random = default!;
    private readonly SharedShuttleSystem _shuttles;
    private readonly SharedTransformSystem _transform;
    private readonly SharedAudioSystem _audio;
    private static readonly SoundSpecifier LockPingSound = new SoundPathSpecifier("/Audio/Effects/Shuttle/radar_ping.ogg");
    private static readonly SoundSpecifier LockConfirmSound = new SoundPathSpecifier("/Audio/Ambience/Objects/alarm.ogg");
    private const float VelocityVectorScale = 1.6f;

    private EntityCoordinates? _coordinates;
    private Angle? _rotation;
    private EntityUid? _consoleEntity;

    /// <summary>
    /// Current snapshot of known targets keyed by entity.
    /// </summary>
    private Dictionary<EntityUid, TargetInfo> _targets = new();

    /// <summary>
    /// Scratch dictionary used during draw to build the new target snapshot.
    /// </summary>
    private Dictionary<EntityUid, TargetInfo> _targetsScratch = new();

    private readonly Dictionary<EntityUid, TargetRenderState> _renderStates = new();
    private List<Entity<MapGridComponent>> _grids = new();

    private EntityUid? _lockedTarget;
    private LockPhase _lockPhase;
    private float _lockQuality;
    private float _lockRatePerSecond;
    private float _lockTimeEstimate = float.PositiveInfinity;
    private TimeSpan _lastLockUpdate;
    private TimeSpan _nextLockPing;
    private TimeSpan _lockAcquiringSince;
    private static readonly TimeSpan LockAcquireDelay = TimeSpan.FromSeconds(1.0);
    private bool _lockTonePlayed;
    private Texture? _lockWeaponIcon;
    private string? _lockWeaponName;
    private TimeSpan _lastUpdateTime;
    private float _currentBeamDegrees;
    private float _currentSectorOffsetDegrees;
    private int _sectorDirection = 1;
    private float _sweepDegreesPerSecond = 90f;
    private bool _isActiveEmission = true;
    private float _passiveNoiseDegrees;
    private float _passiveDistanceNoise;
    private float _passiveRefreshInterval = 1f;
    private TimeSpan _nextPassiveSample;

    public enum RadarScanMode
    {
        Overview,
        Sector
    }

    public enum LockPhase
    {
        None,
        Acquiring,
        Capturing,
        Locked
    }

    public RadarScanMode ScanMode { get; private set; } = RadarScanMode.Overview;
    public float SectorCenterDegrees { get; private set; }
    public float SectorHalfWidthDegrees { get; set; } = 45f;
    public float SectorSweepSpeedMultiplier { get; set; } = 2.5f;
    public LockPhase CurrentLockPhase => _lockPhase;

    public AdvancedShuttleNavControl() : base(64f, 256f, 256f)
    {
        RobustXamlLoader.Load(this);
        _shuttles = EntManager.System<SharedShuttleSystem>();
        _transform = EntManager.System<SharedTransformSystem>();
        _audio = EntManager.System<SharedAudioSystem>();
        _lockWeaponName = Loc.GetString("advanced-radar-lock-weapon-placeholder");
    }

    public event Action<IReadOnlyDictionary<EntityUid, TargetInfo>>? TargetsUpdated;
    public event Action<EntityUid?>? LockedTargetChanged;
    public event Action<RadarScanMode>? ScanModeChanged;
    public event Action<float>? SectorCenterChanged;
    public event Action<bool>? EmissionModeChanged;

    public float SweepDegreesPerSecond
    {
        get => _sweepDegreesPerSecond;
        set
        {
            if (MathHelper.CloseToPercent(_sweepDegreesPerSecond, value))
                return;

            _sweepDegreesPerSecond = value;
            _lastUpdateTime = TimeSpan.Zero;
            _nextPassiveSample = TimeSpan.Zero;
        }
    }

    public float BlipFadeSeconds { get; set; } = 1.6f;
    public float DetectionWidthDegrees { get; set; } = 5f;

    public bool RotateWithEntity { get; set; } = true;

    public bool IsActiveEmission
    {
        get => _isActiveEmission;
        private set
        {
            if (_isActiveEmission == value)
                return;

            _isActiveEmission = value;
            _lastUpdateTime = TimeSpan.Zero;
            _nextPassiveSample = TimeSpan.Zero;
            EmissionModeChanged?.Invoke(value);
        }
    }

    public EntityUid? LockedTarget => _lockedTarget;

    public void SetMatrix(EntityCoordinates? coordinates, Angle? angle)
    {
        _coordinates = coordinates;
        _rotation = angle;
    }

    public void SetConsole(EntityUid? consoleEntity)
    {
        _consoleEntity = consoleEntity;
    }

    public void SetSelectedWeapon(Texture? icon, string? name)
    {
        _lockWeaponIcon = icon;
        _lockWeaponName = string.IsNullOrWhiteSpace(name)
            ? Loc.GetString("advanced-radar-lock-weapon-placeholder")
            : name;
    }

    public void SetEmissionMode(bool active)
    {
        IsActiveEmission = active;
    }

    public void SetScanMode(RadarScanMode mode)
    {
        if (ScanMode == mode)
            return;

        ScanMode = mode;
        ScanModeChanged?.Invoke(ScanMode);
    }

    public void SetSectorCenter(float degrees)
    {
        var normalized = NormalizeDegrees(degrees);
        if (MathHelper.CloseToPercent(normalized, SectorCenterDegrees))
            return;

        SectorCenterDegrees = normalized;
        SectorCenterChanged?.Invoke(SectorCenterDegrees);
    }

    public void UpdateState(NavInterfaceState state)
    {
        SetMatrix(EntManager.GetCoordinates(state.Coordinates), state.Angle);

        WorldMaxRange = state.MaxRange;

        if (WorldMaxRange < WorldRange)
        {
            ActualRadarRange = WorldMaxRange;
        }

        if (WorldMaxRange < WorldMinRange)
            WorldMinRange = WorldMaxRange;

        ActualRadarRange = Math.Clamp(ActualRadarRange, WorldMinRange, WorldMaxRange);

        RotateWithEntity = state.RotateWithEntity;
        _passiveNoiseDegrees = state.PassiveNoiseDegrees;
        _passiveDistanceNoise = state.PassiveDistanceNoise;
        _passiveRefreshInterval = MathF.Max(state.PassiveRefreshInterval, 0.1f);
        IsActiveEmission = state.IsRadarActive;
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);

        DrawBacking(handle);

        if (_coordinates == null || _rotation == null)
        {
            DrawNoSignal(handle);
            ResetTargets();
            return;
        }

        var xformQuery = EntManager.GetEntityQuery<TransformComponent>();

        if (!xformQuery.TryGetComponent(_coordinates.Value.EntityId, out var xform) ||
            xform.MapID == MapId.Nullspace)
        {
            DrawNoSignal(handle);
            ResetTargets();
            return;
        }

        var mapPos = _transform.ToMapCoordinates(_coordinates.Value);
        var posMatrix = Matrix3Helpers.CreateTransform(_coordinates.Value.Position, _rotation.Value);
        var ourRotation = RotateWithEntity ? _transform.GetWorldRotation(xform) : _rotation.Value;
        var ourEntMatrix = Matrix3Helpers.CreateTransform(_transform.GetWorldPosition(xform), ourRotation);
        var shuttleToWorld = Matrix3x2.Multiply(posMatrix, ourEntMatrix);
        Matrix3x2.Invert(shuttleToWorld, out var worldToShuttle);
        var shuttleToView = Matrix3x2.CreateScale(new Vector2(MinimapScale, -MinimapScale)) *
                            Matrix3x2.CreateTranslation(MidPointVector);

        // Draw range rings to provide quick distance cues on the radar.
        DrawCircles(handle);

        var now = Timing.RealTime;
        var beamAngle = GetBeamAngle(now, out var sectorLeft, out var sectorRight);

        if (IsActiveEmission)
        {
            DrawBeam(handle, beamAngle, sectorLeft, sectorRight);
            _nextPassiveSample = TimeSpan.Zero;
        }
        else
        {
            DrawPassiveOverlay(handle, now);
        }

        var shouldUpdateTargets = IsActiveEmission || _nextPassiveSample == TimeSpan.Zero || now >= _nextPassiveSample;

        if (shouldUpdateTargets)
        {
            if (!IsActiveEmission)
                _nextPassiveSample = now + TimeSpan.FromSeconds(_passiveRefreshInterval);

            UpdateTargetData(now, beamAngle, mapPos, xform, ourRotation, worldToShuttle, shuttleToView);
        }

        DrawBlips(handle, now);

        var lockInfo = GetLockInfo();
        if (lockInfo != null)
            DrawLock(handle, lockInfo.Value, now);
    }

    private TargetInfo? GetLockInfo()
    {
        if (_lockedTarget == null)
            return null;

        var uid = _lockedTarget.Value;
        if (_targets.TryGetValue(uid, out var info))
            return info;

        if (ScanMode == RadarScanMode.Sector &&
            _renderStates.TryGetValue(uid, out var state) &&
            state.HasInfo)
        {
            return state.LastInfo;
        }

        return null;
    }

    protected override void KeyBindUp(GUIBoundKeyEventArgs args)
    {
        base.KeyBindUp(args);

        if (args.Function != EngineKeyFunctions.UIClick)
            return;

        if (TryGetTargetAtScreen(args.RelativePosition, out var target))
        {
            TryLockTarget(target);
        }
        else
        {
            ClearLock();
        }
    }

    public bool TryGetTargetInfo(EntityUid uid, out TargetInfo info)
    {
        return _targets.TryGetValue(uid, out info);
    }

    public bool TryLockTarget(EntityUid uid)
    {
        if (!_targets.ContainsKey(uid))
            return false;

        if (_lockedTarget == uid)
        {
            if (_lockPhase == LockPhase.Acquiring)
                SetLockState(uid, LockPhase.Capturing);
            return true;
        }

        SetLockState(uid, LockPhase.Acquiring);
        return true;
    }

    public void ClearLock()
    {
        SetLockState(null, LockPhase.None);
    }

    private void SetLockState(EntityUid? uid, LockPhase phase)
    {
        if (uid == null)
            phase = LockPhase.None;

        var targetChanged = _lockedTarget != uid;

        if (targetChanged || phase == LockPhase.None)
            ResetLockDynamics();

        if (_lockedTarget == uid && _lockPhase == phase)
            return;

        switch (phase)
        {
            case LockPhase.Acquiring:
                ResetLockDynamics();
                _lockAcquiringSince = Timing.RealTime;
                break;
            case LockPhase.Capturing:
                if (_lockPhase != LockPhase.Capturing)
                {
                    _lockAcquiringSince = TimeSpan.Zero;
                    _lastLockUpdate = Timing.RealTime;
                    _nextLockPing = _lastLockUpdate;
                    _lockTonePlayed = false;
                }
                break;
            case LockPhase.Locked:
                _lockQuality = 100f;
                _lockRatePerSecond = 0f;
                _lockTimeEstimate = 0f;
                _nextLockPing = TimeSpan.Zero;
                PlayLockTone();
                break;
            default:
                _lockAcquiringSince = TimeSpan.Zero;
                break;
        }

        _lockPhase = phase;
        _lockedTarget = uid;
        LockedTargetChanged?.Invoke(uid);
    }

    private void ResetLockDynamics()
    {
        _lockQuality = 0f;
        _lockRatePerSecond = 0f;
        _lockTimeEstimate = float.PositiveInfinity;
        _lastLockUpdate = TimeSpan.Zero;
        _nextLockPing = TimeSpan.Zero;
        _lockAcquiringSince = TimeSpan.Zero;
        _lockTonePlayed = false;
    }

    private bool TryGetTargetAtScreen(Vector2 pos, out EntityUid target)
    {
        const float lockRadius = 16f;
        var bestDist = float.MaxValue;
        target = default;
        var found = false;

        foreach (var (uid, info) in _targets)
        {
            var dist = Vector2.Distance(pos, info.ScreenPosition);

            if (dist > lockRadius || dist >= bestDist)
                continue;

            bestDist = dist;
            target = uid;
            found = true;
        }

        return found;
    }

    private void ResetTargets()
    {
        if (_targets.Count == 0 && _renderStates.Count == 0)
            return;

        _targets.Clear();
        _targetsScratch.Clear();
        _renderStates.Clear();
        _lastUpdateTime = TimeSpan.Zero;
        _nextPassiveSample = TimeSpan.Zero;
        SetLockState(null, LockPhase.None);
        TargetsUpdated?.Invoke(_targets);
    }

    private void DrawBeam(
        DrawingHandleScreen handle,
        Angle beamAngle,
        Angle? sectorLeft,
        Angle? sectorRight)
    {
        var direction = beamAngle.ToVec();
        var start = MidPointVector;
        var end = start + new Vector2(direction.X, -direction.Y) * ScaledMinimapRadius;
        var color = Color.Chartreuse.WithAlpha(0.75f);

        handle.DrawCircle(start, 3f, color.WithAlpha(0.5f), filled: true);
        handle.DrawLine(start, end, color);

        if (sectorLeft != null && sectorRight != null)
            DrawSectorBounds(handle, sectorLeft.Value, sectorRight.Value);
    }

    private void DrawPassiveOverlay(DrawingHandleScreen handle, TimeSpan now)
    {
        var pulse = (float)Math.Sin(now.TotalSeconds * 2f);
        var alpha = MathF.Abs(pulse) * 0.15f + 0.05f;
        var color = Color.LightSkyBlue.WithAlpha(alpha);
        handle.DrawCircle(MidPointVector, ScaledMinimapRadius, color);
    }

    private void DrawSectorBounds(DrawingHandleScreen handle, Angle left, Angle right)
    {
        var center = MidPointVector;
        var radius = ScaledMinimapRadius;
        var boundaryColor = Color.LightSkyBlue.WithAlpha(0.35f);

        var leftVec = left.ToVec();
        var rightVec = right.ToVec();
        var leftPoint = center + new Vector2(leftVec.X, -leftVec.Y) * radius;
        var rightPoint = center + new Vector2(rightVec.X, -rightVec.Y) * radius;

        handle.DrawLine(center, leftPoint, boundaryColor);
        handle.DrawLine(center, rightPoint, boundaryColor);

        var span = (right - left).Degrees;
        var steps = Math.Max(8, (int)Math.Ceiling(Math.Abs(span) / 5.0));
        var stepSize = span / steps;
        var previous = leftPoint;

        for (var i = 1; i <= steps; i++)
        {
            var stepAngle = Angle.FromDegrees(left.Degrees + stepSize * i);
            var stepVec = stepAngle.ToVec();
            var point = center + new Vector2(stepVec.X, -stepVec.Y) * radius;
            handle.DrawLine(previous, point, boundaryColor);
            previous = point;
        }
    }

    private void UpdateTargetData(
        TimeSpan now,
        Angle beamAngle,
        MapCoordinates mapPos,
        TransformComponent originXform,
        Angle ourRotation,
        Matrix3x2 worldToShuttle,
        Matrix3x2 shuttleToView)
    {
        var fixturesQuery = EntManager.GetEntityQuery<FixturesComponent>();
        var bodyQuery = EntManager.GetEntityQuery<PhysicsComponent>();
        var metaQuery = EntManager.GetEntityQuery<MetaDataComponent>();

        var detectionHalfWidth = IsActiveEmission ? DetectionWidthDegrees * 0.5f : 180f;
        var mapId = originXform.MapID;
        var ourGridId = originXform.GridUid;

        _targetsScratch.Clear();
        _grids.Clear();
        _mapManager.FindGridsIntersecting(mapId,
            new Box2(mapPos.Position - MaxRadarRangeVector, mapPos.Position + MaxRadarRangeVector),
            ref _grids,
            approx: true,
            includeMap: false);

        foreach (var state in _renderStates.Values)
        {
            state.Present = false;
        }

        foreach (var grid in _grids)
        {
            var gridUid = grid.Owner;

            if (gridUid == ourGridId || !fixturesQuery.HasComponent(gridUid))
                continue;

            if (!bodyQuery.TryGetComponent(gridUid, out var physics))
                continue;

            EntManager.TryGetComponent<IFFComponent>(gridUid, out var iff);

            if (!_shuttles.CanDraw(gridUid, physics, iff))
                continue;

            var worldPosition = _transform.GetWorldPosition(gridUid);
            var relativeWorld = worldPosition - mapPos.Position;
            var distance = relativeWorld.Length();

            if (distance > CornerRadarRange)
                continue;

            var gridToWorld = _transform.GetWorldMatrix(gridUid);
            var gridToView = gridToWorld * worldToShuttle * shuttleToView;
            var screenPosition = Vector2.Transform(physics.LocalCenter, gridToView);

            var state = _renderStates.GetOrNew(gridUid);
            state.ScreenPosition = screenPosition;
            state.Color = _shuttles.GetIFFColor(gridUid, self: false, iff);
            state.Present = true;

            if (TryGetTargetAngle(screenPosition, out var targetAngle))
            {
                var diff = Math.Abs((float)Angle.ShortestDistance(beamAngle, targetAngle).Degrees);

                if (diff <= detectionHalfWidth)
                    state.LastDetection = now;
            }

            var (speed, courseDegrees) = GetSpeedAndCourse(physics, gridUid);
            var bearing = Angle.ShortestDistance(ourRotation, Angle.FromWorldVec(relativeWorld));

            var displayName = _shuttles.GetIFFLabel(gridUid, self: false, iff) ??
                              Loc.GetString("advanced-radar-target-unknown-name");

            var meta = metaQuery.GetComponent(gridUid);
            var targetType = meta.EntityPrototype?.Name;

            if (string.IsNullOrEmpty(targetType))
                targetType = Loc.GetString("advanced-radar-target-unknown-type");

            var info = new TargetInfo
            {
                ScreenPosition = screenPosition,
                Distance = distance,
                Speed = speed,
                CourseDegrees = courseDegrees,
                BearingDegrees = (float)bearing.Degrees,
                DisplayName = displayName,
                TargetType = targetType,
                Color = state.Color,
            };

            if (!IsActiveEmission)
            {
                var bearingNoise = _random.NextFloat(-_passiveNoiseDegrees, _passiveNoiseDegrees);
                var distanceNoise = _random.NextFloat(-_passiveDistanceNoise, _passiveDistanceNoise);
                info = new TargetInfo
                {
                    ScreenPosition = screenPosition,
                    Distance = MathF.Max(0f, distance + distanceNoise),
                    Speed = speed,
                    CourseDegrees = courseDegrees,
                    BearingDegrees = NormalizeDegrees((float)bearing.Degrees + bearingNoise),
                    DisplayName = displayName,
                    TargetType = targetType,
                    Color = state.Color,
                };
                state.LastDetection = now;
            }

            if (state.HasInfo)
            {
                state.PreviousInfo = state.LastInfo;
                state.HasPrevious = true;
            }
            else
            {
                state.HasPrevious = false;
            }

            state.LastInfo = info;
            state.HasInfo = true;

            var active = state.LastDetection != TimeSpan.Zero &&
                         (now - state.LastDetection).TotalSeconds <= BlipFadeSeconds;

            if (active)
                _targetsScratch[gridUid] = info;
        }

        var toRemove = new ValueList<EntityUid>();

        foreach (var (uid, state) in _renderStates)
        {
            if (!state.Present)
            {
                toRemove.Add(uid);
                continue;
            }

            state.Present = false;
        }

        foreach (var uid in toRemove)
        {
            if (ScanMode == RadarScanMode.Sector && _lockedTarget == uid)
                continue;

            _renderStates.Remove(uid);
        }

        (_targets, _targetsScratch) = (_targetsScratch, _targets);
        _targetsScratch.Clear();

        if (_lockedTarget != null)
        {
            var uid = _lockedTarget.Value;
            var hasTargetInfo = _targets.ContainsKey(uid);
            var hasRenderState = _renderStates.TryGetValue(uid, out var lockedState);

            if (!hasTargetInfo)
            {
                if (!hasRenderState || lockedState == null || !lockedState.Present)
                    SetLockState(null, LockPhase.None);
            }
        }

        TargetsUpdated?.Invoke(_targets);
    }

    private void DrawBlips(DrawingHandleScreen handle, TimeSpan now)
    {
        foreach (var state in _renderStates.Values)
        {
            if (state.LastDetection == TimeSpan.Zero)
                continue;

            var elapsed = (float)(now - state.LastDetection).TotalSeconds;

            if (elapsed < 0f || elapsed > BlipFadeSeconds)
                continue;

            var fade = 1f - elapsed / BlipFadeSeconds;
            var color = state.Color.WithAlpha(Math.Clamp(fade, 0f, 1f));

            handle.DrawCircle(state.ScreenPosition, 6f, color);
            handle.DrawCircle(state.ScreenPosition, 3f, color.WithAlpha(Math.Clamp(fade * 1.5f, 0f, 1f)), filled: true);
        }
    }

    private void DrawLock(DrawingHandleScreen handle, in TargetInfo info, TimeSpan now)
    {
        if (_lockPhase == LockPhase.Acquiring)
            HandleAcquisitionTiming(now);
        else if (_lockPhase == LockPhase.Capturing)
            UpdateCapturingState(info, now);

        switch (_lockPhase)
        {
            case LockPhase.Acquiring:
                DrawAcquisitionMarker(handle, info, now);
                break;
            case LockPhase.Capturing:
                DrawCapturingMarker(handle, info, now);
                DrawCapturingHud(handle, info);
                break;
            case LockPhase.Locked:
                DrawLockedMarker(handle, info, now);
                DrawLockedHud(handle, info);
                break;
        }
    }

    private void HandleAcquisitionTiming(TimeSpan now)
    {
        if (_lockedTarget == null)
            return;

        if (_lockAcquiringSince == TimeSpan.Zero)
            _lockAcquiringSince = now;

        if (now - _lockAcquiringSince >= LockAcquireDelay)
            SetLockState(_lockedTarget, LockPhase.Capturing);
    }

    private void UpdateCapturingState(in TargetInfo info, TimeSpan now)
    {
        if (_lastLockUpdate == TimeSpan.Zero)
        {
            _lastLockUpdate = now;
            if (_nextLockPing == TimeSpan.Zero)
                _nextLockPing = now;
            return;
        }

        var delta = (float)(now - _lastLockUpdate).TotalSeconds;
        if (delta <= 0f)
            return;
        _lastLockUpdate = now;

        var distanceFactor = Math.Clamp(1f - info.Distance / Math.Max(1f, MaxRadarRange), 0f, 1f);
        distanceFactor = MathF.Pow(distanceFactor, 0.5f);

        var stabilityFactor = 1f - Math.Clamp(info.Speed / 60f, 0f, 1f);
        stabilityFactor = MathF.Pow(stabilityFactor, 1.2f);

        var maneuverPenalty = 0f;

        if (_lockedTarget != null &&
            _renderStates.TryGetValue(_lockedTarget.Value, out var state) &&
            state.HasPrevious)
        {
            var previous = state.PreviousInfo;
            var speedDelta = MathF.Abs(info.Speed - previous.Speed);
            var courseDelta = DegreesDistance(info.CourseDegrees, previous.CourseDegrees);
            var bearingDelta = DegreesDistance(info.BearingDegrees, previous.BearingDegrees);

            maneuverPenalty = speedDelta * 0.4f + courseDelta * 0.12f + bearingDelta * 0.06f;
        }

        var baseRate = 15f + 45f * distanceFactor;
        baseRate *= 0.4f + 0.6f * stabilityFactor;

        var netRate = baseRate - maneuverPenalty;
        _lockRatePerSecond = netRate;

        _lockQuality = Math.Clamp(_lockQuality + netRate * delta, 0f, 100f);

        if (_lockQuality <= 0.01f && netRate <= 0f)
        {
            SetLockState(_lockedTarget, LockPhase.Acquiring);
            return;
        }

        if (_lockQuality >= 99.5f)
        {
            SetLockState(_lockedTarget, LockPhase.Locked);
            return;
        }

        _lockTimeEstimate = netRate > 0.05f
            ? MathF.Max(0.1f, (100f - _lockQuality) / netRate)
            : float.PositiveInfinity;

        UpdateLockPing(now);
    }

    private void UpdateLockPing(TimeSpan now)
    {
        if (_consoleEntity == null)
            return;

        if (_nextLockPing == TimeSpan.Zero)
            _nextLockPing = now;

        if (now < _nextLockPing)
            return;

        var progress = Math.Clamp(_lockQuality / 100f, 0f, 1f);
        var interval = MathHelper.Lerp(1.3f, 0.25f, progress);
        interval = MathF.Max(0.18f, interval);

        _audio.PlayEntity(LockPingSound, Filter.Local(), _consoleEntity.Value, true);
        _nextLockPing = now + TimeSpan.FromSeconds(interval);
    }

    private void PlayLockTone()
    {
        if (_consoleEntity == null || _lockTonePlayed)
            return;

        _audio.PlayEntity(LockConfirmSound, Filter.Local(), _consoleEntity.Value, true, AudioParams.Default.WithVolume(-4f));
        _lockTonePlayed = true;
    }

    private void DrawAcquisitionMarker(DrawingHandleScreen handle, in TargetInfo info, TimeSpan now)
    {
        const float diamondRadius = 14f;
        var pos = info.ScreenPosition;
        var color = Color.White.WithAlpha(0.9f);
        var offset = (float)(now.TotalSeconds * 24f);

        var top = pos + new Vector2(0f, -diamondRadius);
        var right = pos + new Vector2(diamondRadius, 0f);
        var bottom = pos + new Vector2(0f, diamondRadius);
        var left = pos + new Vector2(-diamondRadius, 0f);

        handle.DrawDottedLine(top, right, color, offset, dashSize: 6f, gapSize: 3f);
        handle.DrawDottedLine(right, bottom, color, offset, dashSize: 6f, gapSize: 3f);
        handle.DrawDottedLine(bottom, left, color, offset, dashSize: 6f, gapSize: 3f);
        handle.DrawDottedLine(left, top, color, offset, dashSize: 6f, gapSize: 3f);

        DrawAcquisitionInfo(handle, info, color);
    }

    private void DrawCapturingMarker(DrawingHandleScreen handle, in TargetInfo info, TimeSpan now)
    {
        var progress = Math.Clamp(_lockQuality / 100f, 0f, 1f);
        var baseRadius = MathHelper.Lerp(26f, 8f, progress);
        var pulse = (MathF.Sin((float)now.TotalSeconds * 3f) + 1f) * 0.5f;
        var animatedRadius = baseRadius + (1f - progress) * pulse * 2f;
        var cornerLength = MathHelper.Lerp(16f, 6f, progress);
        var inner = MathF.Max(2f, animatedRadius - cornerLength);
        var color = Color.LimeGreen.WithAlpha(0.95f);
        var pos = info.ScreenPosition;

        DrawChevronCorner(handle,
            pos + new Vector2(-animatedRadius, -inner),
            pos + new Vector2(-animatedRadius, -animatedRadius),
            pos + new Vector2(-inner, -animatedRadius),
            color);
        DrawChevronCorner(handle,
            pos + new Vector2(animatedRadius, -inner),
            pos + new Vector2(animatedRadius, -animatedRadius),
            pos + new Vector2(inner, -animatedRadius),
            color);
        DrawChevronCorner(handle,
            pos + new Vector2(-animatedRadius, inner),
            pos + new Vector2(-animatedRadius, animatedRadius),
            pos + new Vector2(-inner, animatedRadius),
            color);
        DrawChevronCorner(handle,
            pos + new Vector2(animatedRadius, inner),
            pos + new Vector2(animatedRadius, animatedRadius),
            pos + new Vector2(inner, animatedRadius),
            color);
    }

    private void DrawCapturingHud(DrawingHandleScreen handle, in TargetInfo info)
    {
        var lines = new ValueList<string>();

        if (!string.IsNullOrWhiteSpace(info.DisplayName))
            lines.Add(info.DisplayName);
        else if (!string.IsNullOrWhiteSpace(info.TargetType))
            lines.Add(info.TargetType);

        var distanceKm = info.Distance / 1000f;
        lines.Add(Loc.GetString("advanced-radar-lock-distance-km", ("distance", $"{distanceKm:0.0}")));

        var quality = Math.Clamp(_lockQuality, 0f, 100f);
        lines.Add(Loc.GetString("advanced-radar-lock-quality", ("value", $"{quality:0}")));

        string timeLine;
        if (float.IsPositiveInfinity(_lockTimeEstimate))
            timeLine = Loc.GetString("advanced-radar-lock-time-undetermined");
        else
            timeLine = Loc.GetString("advanced-radar-lock-time", ("value", $"{_lockTimeEstimate:0.0}"));
        lines.Add(timeLine);

        var color = Color.LimeGreen.WithAlpha(0.95f);
        var cursor = info.ScreenPosition + new Vector2(22f, -30f);

        foreach (var line in lines)
        {
            var dims = handle.GetDimensions(Font, line, 1f);
            handle.DrawString(Font, cursor, line, color);
            cursor.Y += dims.Y + 2f;
        }
    }

    private void DrawLockedMarker(DrawingHandleScreen handle, in TargetInfo info, TimeSpan now)
    {
        const float outerRadius = 16f;
        var fillColor = Color.Crimson.WithAlpha(0.85f);
        var borderColor = Color.White.WithAlpha(0.95f);
        var pos = info.ScreenPosition;

        var top = pos + new Vector2(0f, -outerRadius);
        var right = pos + new Vector2(outerRadius, 0f);
        var bottom = pos + new Vector2(0f, outerRadius);
        var left = pos + new Vector2(-outerRadius, 0f);

        var fillVertices = new[]
        {
            pos, top, right,
            pos, right, bottom,
            pos, bottom, left,
            pos, left, top
        };

        handle.DrawPrimitives(DrawPrimitiveTopology.TriangleList, fillVertices, fillColor);

        var outlineVertices = new[]
        {
            top,
            right,
            bottom,
            left,
            top
        };
        handle.DrawPrimitives(DrawPrimitiveTopology.LineStrip, outlineVertices, borderColor);
    }

    private void DrawAcquisitionInfo(DrawingHandleScreen handle, in TargetInfo info, Color color)
    {
        var lines = new ValueList<string>();

        if (!string.IsNullOrWhiteSpace(info.DisplayName))
            lines.Add(info.DisplayName);
        else if (!string.IsNullOrWhiteSpace(info.TargetType))
            lines.Add(info.TargetType);

        var distanceKm = info.Distance / 1000f;
        var distanceText = Loc.GetString("advanced-radar-lock-distance-km",
            ("distance", $"{distanceKm:0.0}"));
        lines.Add(distanceText);

        if (lines.Count == 0)
            return;

        var cursor = info.ScreenPosition + new Vector2(18f, -18f);

        foreach (var line in lines)
        {
            var dims = handle.GetDimensions(Font, line, 1f);
            handle.DrawString(Font, cursor, line, color);
            cursor.Y += dims.Y + 2f;
        }
    }

    private void DrawLockedHud(DrawingHandleScreen handle, in TargetInfo info)
    {
        DrawVelocityVector(handle, info);

        var color = Color.White.WithAlpha(0.95f);
        var highlight = Color.Crimson.WithAlpha(0.95f);
        var cursor = info.ScreenPosition + new Vector2(28f, -46f);

        var fireText = Loc.GetString("advanced-radar-lock-fire-authorized");
        var fireDims = handle.GetDimensions(Font, fireText, 1f);
        handle.DrawString(Font, cursor, fireText, highlight);
        cursor.Y += fireDims.Y + 6f;

        var infoLines = new ValueList<string>
        {
            Loc.GetString("advanced-radar-lock-distance", ("distance", $"{info.Distance:0}")),
            Loc.GetString("advanced-radar-lock-speed", ("speed", $"{info.Speed:0.0}")),
            Loc.GetString("advanced-radar-lock-type", ("type", info.TargetType))
        };

        var weaponLabel = _lockWeaponName ?? Loc.GetString("advanced-radar-lock-weapon-none");
        infoLines.Add(Loc.GetString("advanced-radar-lock-weapon", ("weapon", weaponLabel)));

        foreach (var line in infoLines)
        {
            var dims = handle.GetDimensions(Font, line, 1f);
            handle.DrawString(Font, cursor, line, color);
            cursor.Y += dims.Y + 4f;
        }

        if (_lockWeaponIcon != null)
        {
            var iconSize = new Vector2(24f, 24f);
            var iconPosition = info.ScreenPosition + new Vector2(4f, -32f);
            handle.DrawTextureRect(_lockWeaponIcon, new UIBox2(iconPosition, iconPosition + iconSize));
        }
        else
        {
            var iconPosition = info.ScreenPosition + new Vector2(4f, -32f);
            DrawWeaponPlaceholder(handle, iconPosition, weaponLabel);
        }
    }

    private void DrawVelocityVector(DrawingHandleScreen handle, in TargetInfo info)
    {
        var direction = Angle.FromDegrees(info.CourseDegrees).ToVec();
        var screenDir = new Vector2(direction.X, -direction.Y);
        if (screenDir.LengthSquared() <= 0.0001f)
            return;

        screenDir = Vector2.Normalize(screenDir);
        var length = Math.Clamp(info.Speed * VelocityVectorScale, 12f, 80f);
        var start = info.ScreenPosition;
        var end = start + screenDir * length;
        var vectorColor = Color.Crimson.WithAlpha(0.95f);

        handle.DrawLine(start, end, vectorColor);

        var arrowBase = end - screenDir * 8f;
        var perpendicular = new Vector2(-screenDir.Y, screenDir.X) * 4f;
        handle.DrawLine(arrowBase + perpendicular, end, vectorColor);
        handle.DrawLine(arrowBase - perpendicular, end, vectorColor);
    }

    private void DrawWeaponPlaceholder(DrawingHandleScreen handle, Vector2 topLeft, string label)
    {
        var boxSize = new Vector2(24f, 24f);
        var box = new UIBox2(topLeft, topLeft + boxSize);
        var baseColor = Color.Crimson.WithAlpha(0.6f);
        var borderColor = Color.White.WithAlpha(0.9f);

        handle.DrawRect(box, baseColor, true);
        handle.DrawRect(box, borderColor, false);

        var glyph = string.IsNullOrWhiteSpace(label) ? "?" : char.ToUpperInvariant(label[0]).ToString();
        var dims = handle.GetDimensions(Font, glyph, 1f);
        var textPos = topLeft + (boxSize - dims) / 2f;
        handle.DrawString(Font, textPos, glyph, Color.White.WithAlpha(0.95f));
    }

    private static void DrawChevronCorner(
        DrawingHandleScreen handle,
        Vector2 start,
        Vector2 corner,
        Vector2 end,
        Color color)
    {
        handle.DrawLine(start, corner, color);
        handle.DrawLine(corner, end, color);
    }

    private bool TryGetTargetAngle(Vector2 screenPosition, out Angle angle)
    {
        var relative = screenPosition - MidPointVector;

        if (relative.LengthSquared() <= 0.001f)
        {
            angle = Angle.Zero;
            return false;
        }

        var normalized = Vector2.Normalize(relative);
        var adjusted = new Vector2(normalized.X, -normalized.Y);
        angle = new Angle(adjusted);
        return true;
    }

    private (float Speed, float Course) GetSpeedAndCourse(PhysicsComponent physics, EntityUid uid)
    {
        var velocity = physics.LinearVelocity;
        var speed = velocity.Length();

        float course;

        if (speed > 0.01f)
        {
            course = (float)Angle.FromWorldVec(velocity).Degrees;
        }
        else
        {
            course = (float)_transform.GetWorldRotation(uid).Degrees;
        }

        return (speed, course);
    }

    private Angle GetBeamAngle(TimeSpan now, out Angle? sectorLeft, out Angle? sectorRight)
    {
        sectorLeft = null;
        sectorRight = null;

        if (_lastUpdateTime == TimeSpan.Zero)
        {
            _lastUpdateTime = now;
            return Angle.FromDegrees(_currentBeamDegrees);
        }

        var delta = (float)(now - _lastUpdateTime).TotalSeconds;
        if (delta < 0f)
            delta = 0f;
        else if (delta > 0.5f)
            delta = 0.5f;

        _lastUpdateTime = now;

        if (ScanMode == RadarScanMode.Overview)
        {
            _currentBeamDegrees = NormalizeDegrees(_currentBeamDegrees + _sweepDegreesPerSecond * delta);
            return Angle.FromDegrees(_currentBeamDegrees);
        }

        var center = SectorCenterDegrees;
        var half = MathF.Max(SectorHalfWidthDegrees, 1f);
        sectorLeft = Angle.FromDegrees(center - half);
        sectorRight = Angle.FromDegrees(center + half);

        var speed = _sweepDegreesPerSecond * SectorSweepSpeedMultiplier;
        var offset = _currentSectorOffsetDegrees + speed * delta * _sectorDirection;

        while (offset > half || offset < -half)
        {
            if (offset > half)
            {
                offset = half - (offset - half);
                _sectorDirection = -1;
            }
            else
            {
                offset = -half + (-half - offset);
                _sectorDirection = 1;
            }
        }

        _currentSectorOffsetDegrees = offset;
        _currentBeamDegrees = NormalizeDegrees(center + offset);
        return Angle.FromDegrees(_currentBeamDegrees);
    }

    private static float NormalizeDegrees(float degrees)
    {
        var result = degrees % 360f;
        if (result < 0f)
            result += 360f;
        return result;
    }

    private static float DegreesDistance(float a, float b)
    {
        var diff = MathF.Abs(NormalizeDegrees(a - b));
        return diff > 180f ? 360f - diff : diff;
    }

    public readonly struct TargetInfo
    {
        public Vector2 ScreenPosition { get; init; }
        public float Distance { get; init; }
        public float Speed { get; init; }
        public float CourseDegrees { get; init; }
        public float BearingDegrees { get; init; }
        public string DisplayName { get; init; }
        public string TargetType { get; init; }
        public Color Color { get; init; }
    }

    private sealed class TargetRenderState
    {
        public Vector2 ScreenPosition;
        public TimeSpan LastDetection;
        public Color Color;
        public bool Present;
        public bool HasInfo;
        public bool HasPrevious;
        public TargetInfo LastInfo;
        public TargetInfo PreviousInfo;
    }
}


